diff --git a/src/http/modules/ngx_http_auth_request_module.c b/src/http/modules/ngx_http_auth_request_module.c
index b4307be..67ae07c 100644
--- a/src/http/modules/ngx_http_auth_request_module.c
+++ b/src/http/modules/ngx_http_auth_request_module.c
@@ -12,6 +12,7 @@
 
 typedef struct {
     ngx_str_t                 uri;
+    ngx_uint_t                authorizer;
     ngx_array_t              *vars;
 } ngx_http_auth_request_conf_t;
 
@@ -50,7 +51,7 @@ static char *ngx_http_auth_request_set(ngx_conf_t *cf, ngx_command_t *cmd,
 static ngx_command_t  ngx_http_auth_request_commands[] = {
 
     { ngx_string("auth_request"),
-      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_1MORE,
       ngx_http_auth_request,
       NGX_HTTP_LOC_CONF_OFFSET,
       0,
@@ -101,7 +102,9 @@ ngx_module_t  ngx_http_auth_request_module = {
 static ngx_int_t
 ngx_http_auth_request_handler(ngx_http_request_t *r)
 {
-    ngx_table_elt_t               *h, *ho;
+    ngx_uint_t                    i;
+    ngx_list_part_t               *part;
+    ngx_table_elt_t               *h, *ho, *hi;
     ngx_http_request_t            *sr;
     ngx_http_post_subrequest_t    *ps;
     ngx_http_auth_request_ctx_t   *ctx;
@@ -132,6 +135,83 @@ ngx_http_auth_request_handler(ngx_http_request_t *r)
             return NGX_ERROR;
         }
 
+        /*
+         * if authorizer mode is configured, handle the subrequest
+         * as per the FastCGI authorizer specification.
+         */ 
+        if (arcf->authorizer) {
+            ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                           "auth request authorizer handler");
+            sr = ctx->subrequest;
+
+            if (ctx->status == NGX_HTTP_OK) {
+                /* 
+                 * 200 response may include headers prefixed with `Variable-`
+                 * back into initial headers
+                 */
+                ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                           "auth request authorizer allows access");
+
+                part = &sr->headers_out.headers.part;
+                h = part->elts;
+
+                for (i = 0; /* void */; i++) {
+
+                    if (i >= part->nelts) {
+                        if (part->next == NULL) {
+                            break;
+                        }
+
+                        part = part->next;
+                        h = part->elts;
+                        i = 0;
+                    }
+
+                    if (h[i].hash == 0) {
+                        continue;
+                    }
+
+                    if (ngx_strncasecmp(h[i].key.data,
+                        (u_char *) "Variable-", 9) == 0) {
+                        /* copy header into original request */
+                        hi = ngx_list_push(&r->headers_in.headers);
+
+                        if (hi == NULL) {
+                            return NGX_HTTP_INTERNAL_SERVER_ERROR;
+                        }
+
+                        /* Strip the Variable- prefix */
+                        hi->key.len = h[i].key.len - 9;
+                        hi->key.data = h[i].key.data + 9;
+                        hi->value = h[i].value;
+
+                        hi->lowcase_key = ngx_pnalloc(r->pool, hi->key.len);
+                        if (hi->lowcase_key == NULL) {
+                            return NGX_HTTP_INTERNAL_SERVER_ERROR;
+                        }
+                        ngx_strlow(hi->lowcase_key, hi->key.data, hi->key.len);
+
+                        ngx_log_debug2(
+                          NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                          "auth request authorizer copied header: \"%V: %V\"",
+                          &hi->key, &hi->value);
+                    }
+                }
+                
+                return NGX_OK;
+            }
+
+            /* 
+             * Unconditionally return subrequest response status, headers 
+             * and content.
+             */
+            ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                           "auth request authorizer returning sub-response");
+
+            r->headers_out = sr->headers_out;
+            return ctx->status;
+        }
+
         /* return appropriate status */
 
         if (ctx->status == NGX_HTTP_FORBIDDEN) {
@@ -203,6 +283,11 @@ ngx_http_auth_request_handler(ngx_http_request_t *r)
         return NGX_ERROR;
     }
 
+    /* 
+     * true FastCGI authorizers should conditionally return the subrequest 
+     * response body but the FastCGI handler does not support
+     * NGX_HTTP_SUBREQUEST_IN_MEMORY at present.
+     */
     sr->header_only = 1;
 
     ctx->subrequest = sr;
@@ -358,7 +443,8 @@ ngx_http_auth_request(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
 {
     ngx_http_auth_request_conf_t *arcf = conf;
 
-    ngx_str_t        *value;
+    ngx_uint_t       i;
+    ngx_str_t        *value, s;
 
     if (arcf->uri.data != NULL) {
         return "is duplicate";
@@ -375,6 +461,18 @@ ngx_http_auth_request(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
 
     arcf->uri = value[1];
 
+    for (i = 2; i < cf->args->nelts; i++) {
+
+        if (ngx_strncmp(value[i].data, "authorizer=", 11) == 0) {
+            s.len = value[i].len - 11;
+            s.data = value[i].data + 11;
+            if (ngx_strcmp(s.data, "on") == 0) {
+                arcf->authorizer = 1;
+            }
+        }
+    }
+
+
     return NGX_CONF_OK;
 }
 
@@ -441,4 +539,4 @@ ngx_http_auth_request_set(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
     }
 
     return NGX_CONF_OK;
-}
+}
\ No newline at end of file
